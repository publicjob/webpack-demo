业务场景：

1.在business.js这份业务代码中import _ from 'lodash'，在经过webpack普通打包之后，将会把业务代码和第三方库lodash的代码打包在一个文件里头

2.最终拿着这份dist发布，用户浏览器可以正常下载下来的，但是这样子存在一个这样的问题：

  假设：业务代码文件有1M，lodash库代码有1M，那么最终可能打包出来的体积就是2M（因为打包在了一个文件里头）

3.在这种情况下，用户浏览器需要下载下来一个2M的文件。这样子整个文件会下载的比较慢，因为浏览器是可以并行下载的，我们完全可以将一个大文件分成多个小文件，然后并行下载多个小文件，这样子下载的速度可能就提升了，页面加载速度也提升了

4.另外，浏览器是带有缓存的，一般我们发布都是对发布的资源打上哈希后缀，如果文件的内容不变，那么这个哈希值就不会变。当浏览器第一次下载这些文件的时候，会缓存下来这些文件。我们的业务代码是会不断更新的，但是lodash库这种第三方代码是不会经常变动的。这样子，如果我们让业务代码跟第三方库代码融合在一块打包，那么只要业务代码一变，我们的资源最终打包出来的哈希后缀就会变化，如果我们不分割业务代码和第三方库代码，那么我们最终让浏览器下载的文件又是一个新的大文件，因为浏览器是根据URL进行资源寻找的，如果URL在缓存中有，就默认去找缓存，限制url变了（因为哈希变了），浏览器就会重新下载新的文件，这样子又是下载一次2M大文件，完全浪费带宽，没有必要，因为第三方库本来就没做改变，却因为业务代码变化了要被连累到。

5.因此代码分割code splitting的重要性就体现出来了：

我们将第三方库代码和业务代码进行分割，单独存放第三方库打包代码，这样子由于这个包的代码不经常变动，每次webpack打包出来的资源哈希后缀一样，那么浏览器就不会再去加载新资源。同时，我们只需要加载1M的业务代码了，加载文件体积变小了，加载速度提升了，用户体验也就提高了。

手动代码分割：
手动代码分割需要考虑很多东西，同时有风险，如我们打包的时候配置入口，将第三方库的打包放在后边，业务代码放在了前边，那么就会导致执行顺序错误，代码无法运行，最终浏览器控制台报错的情况。
而且我们是将lodash作为window的属性成为全局变量来搞定的